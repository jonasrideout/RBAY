generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum SchoolStatus {
  COLLECTING
  READY
  MATCHED
  CORRESPONDING
  DONE
}

enum PenpalPreference {
  ONE
  MULTIPLE
}

model SchoolGroup {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationships
  schools   School[]
  
  // Matching happens at GROUP level
  status            SchoolStatus @default(COLLECTING)
  readyForMatching  Boolean      @default(false)
  
  // When matched with another group or individual school
  // Can contain either a valid SchoolGroup ID OR a marker like "school:xxx"
  matchedWithGroupId String?     @unique
  
  @@map("school_groups")
}

model School {
  id                   String        @id @default(cuid())
  schoolName           String
  teacherName          String
  teacherEmail         String        @unique
  teacherPhone         String?
  dashboardToken       String        @unique @default(cuid())
  schoolAddress        String?
  schoolCity           String?
  schoolState          String
  schoolZip            String?
  gradeLevel           String
  expectedClassSize    Int
  startMonth           String
  specialConsiderations String?
  status               SchoolStatus  @default(COLLECTING)
  region               String
  isActive             Boolean       @default(true)
  
  // Group membership
  schoolGroupId        String?
  schoolGroup          SchoolGroup?  @relation(fields: [schoolGroupId], references: [id])
  
  // One-to-one school pairing
  // Can contain either a valid School ID OR a marker like "group:xxx" for cross-type matches
  matchedWithSchoolId  String?       @unique
  notificationEmailsSent Boolean     @default(false)
  
  // Future letter tracking fields (optional for now)
  letterFrequency      String?
  lettersSent          Int?          @default(0)
  lettersReceived      Int?          @default(0)
  
  students             Student[]
  schoolPairings       SchoolPairing[] @relation("School1Pairings")
  pairedWithSchools    SchoolPairing[] @relation("School2Pairings")
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  
  @@map("schools")
}

model Student {
  id                String           @id @default(cuid())
  firstName         String
  lastInitial       String
  grade             String
  interests         String[]
  otherInterests    String?
  parentConsent     Boolean          @default(false)
  penpalPreference  PenpalPreference @default(ONE)
  isActive          Boolean          @default(true)
  profileCompleted  Boolean          @default(false)
  schoolId          String
  school            School           @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  penpalConnections StudentPenpal[]  @relation("StudentConnections")
  penpalOf          StudentPenpal[]  @relation("PenpalOf")
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  @@map("students")
}

model SchoolPairing {
  id        String   @id @default(cuid())
  school1Id String
  school2Id String
  school1   School   @relation("School1Pairings", fields: [school1Id], references: [id], onDelete: Cascade)
  school2   School   @relation("School2Pairings", fields: [school2Id], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([school1Id, school2Id])
  @@map("school_pairings")
}

model StudentPenpal {
  id        String   @id @default(cuid())
  studentId String
  penpalId  String
  student   Student  @relation("StudentConnections", fields: [studentId], references: [id], onDelete: Cascade)
  penpal    Student  @relation("PenpalOf", fields: [penpalId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([studentId, penpalId])
  @@map("student_penpals")
}
